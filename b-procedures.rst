过程调用
=========

运行时栈是直接由处理器管理的内存数组，用于跟踪过程返回地址、参数、局部变量、和其他过程相
关数据。在32位模式下，栈指针寄存器 ESP 保存着32位的栈位置地址。我们一般很少直接操作 ESP，
而是使用 CALL、RET、PUSH、POP 等指令间接操作。

ESP 总是保存最新的栈顶元素的地址，PUSH 指令将 ESP 向低位置偏移一个元素然后将新元素压入
新的栈顶，POP 获取当前栈顶元素的一份拷贝然后将 ESP 向高位置增加一个元素的偏移。栈可用来
临时保存寄存器的值，当执行 CALL 指令时 CPU 会将当前过程的返回地址保存到栈中，当调用过程
时可以将额外的参数放到栈中，另外栈还是保存过程局部变量的场所。

使用 PROC 汇编命令来定义一个过程，除了程序的起始过程，都需要使用 RET 指令让处理器返回到
主调函数的调用位置之后继续执行后续指令。 ::

    func PROC
        ...
        ret
    func ENDP

过程中可以定义标签，代码标签只在过程内部可见，代码标签一般用于分支或循环指令的跳转目标。
但是可以定义全局的代码标签，使用双冒号定义。但对于程序设计来说，从当前过程跳转到外部不是
一个好主意。过程会自动返回和跳转运行时栈，如果将控制权直接转移到外部，运行时栈很容易遭到
破坏。

调用过程时，CALL 指令将当前过程的返回位置的地址压入栈中，并将被调过程的第一条指令的地址
写入指令指针 EIP。但过程返回时，RET 指令会将返回地址出栈保存到指令指针 EIP 寄存器中。嵌
套过程调用是指被调过程在返回之前后调用了另一个过程，甚至可以是递归调用，即在当前调用链中
继续调用了调用链中已经调用过的过程。

在 PROC 声明中可以使用 USES 让汇编器自动保存和恢复过程内部使用的寄存器，USES 告诉汇编器
两件事：第一，在过程开始处生成 PUSH 指令将指定的寄存器保存到栈中；第二，在过程返回前生成
POP 指令将指定的寄存器从栈中恢复。但是，不能对返回值寄存器进行保存和恢复，因为返回值寄存
器需要保存过程的返回值，不能被覆盖成原来的值。

微软 x64 调用约定
-----------------

微软在 64 位程序中遵从一致的参数传递和过程调用约定，称为微软 x64 调用约定。这个约定用于
C/C++ 编译器，也用于 Windows API。以下是这个调用约定的基本行为：

1. CALL 指令会将 RSP 寄存器的值减去 8 保存返回地址
2. 过程最开头的四个参数依次通过 RCX、RDX、R8、R9 四个寄存器传递，额外的参数会按从左到右
   的顺序依次压入栈中通过栈传递
3. 过程调用者需要负责分配至少 32 个字节（4 * 8）的 shadow space 栈空间，让被调过程能够
   可选将寄存器参数保存到这个区域
4. 当调用过程时，被调过程可以使用的第一个栈元素必须对齐到 16 字节地址边界，即进入被调过
   程后的 RSP + 8 必须是 16 的倍数

下面的例子展示了在调用过程时怎样将 RSP 对齐以及预留 shadow space 空间： ::

     1: .code
     2: main PROC
     3:     sub rsp,8   ; RSP 对齐预留，如果有奇数个额外参数这里可以不预留
     4:     sub rsp,32  ; 预留 shadow space
     5:     mov rcx,1   ; 传递寄存器参数
     6:     mov rdx,2
     7:     mov r8,3
     8:     mov r9,4
     9:     push 5      ; 传递额外参数
    10:     push 6
    11:     call addsix
    12:
    13:     add rsp,40
    14:     mov ecx,0   ; 返回到操作系统
    15:     ret
    16: main ENDP

    过程 addsix 在执行第一条指令前栈的状态：
    |XXX返回操作系统XX| 0x1068 <- 进入 main 时的栈顶，main 可以使用的下一元素是对齐的
    |                | 0x1060 sub rsp,8  预留 8 个字节
    |                | 0x1058
    |                | 0x1050
    |                | 0x1048
    |                | 0x1040 sub rsp,32 预留 32 个字节
    |    参数5       | 0x1038
    |    参数6       | 0x1030
    |CALL填入返回地址 | 0x1028 <- RSP 当前栈顶指针，下一个可使用的元素是对齐的
    |                | 0x1020

如上图所示，只要向第 3 行和第 4 行那样一共预留 40 个字节的栈空间，就可以同时满足 shadow
space 和 RSP 对齐的要求。这里一个前提是，当前过程在进入时已经保证 RSP 对齐。

